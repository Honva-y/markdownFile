#### JVM主要包含了两个子系统和两个组件。

子系统：class Loader（类加载器）、Execution engine(执行器引擎)

组件：JMM（运行时数据区，runtime data area也叫JMM，Java memory model）、NI（本地库接口native interface）

其中，重要主要考察的部分是JMM，因为包含了数据文件对象的生命周期运转

JMM一共有五个部分：方法区（method area）,VM stack(虚拟机栈)，本地方法栈（native method stack），程序计数器（program count register），堆（heap）

https://blog.csdn.net/thinkwon/article/details/104390752



#### 介绍下运行时数据区（JMM）

数据运行区划分为五个小部分，如下图所示

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/JVM-RDA.png )

方法区（method area）:存储已被虚拟机加载的类信息、常量，静态变量，即时编译后的代码等数据，属于线程共享数据区。常量池是方法区的一部分，存放即时编译期间生成的字面常量和符号引用，jdk1.8后**方法区（Method Area）**被元空间(Metaspace)代替。

Java堆：JVM中最大的一块内存，几乎所有对象实例都在这里分配内存（什么对象不分配在堆？），属于线程共享数据区，内存由垃圾收集器自动回收

JVM stack（虚拟机栈）：每一个栈针用于存储局部变量，操作数栈（复制，交换，计算等操作），动态链接（指向了方法区中常量池的方法引用），方法出口等信息，属于线程私有的内存区。

Native method stack(本地方法栈)：与虚拟机栈类似。区别在于虚拟机栈服务于Java方法，本地方法栈服务于JVM的native 方法

program counter register（程序计数器）：当前线程执行的 字节码行号 指示器，字节码**解析器**通过改变计数器的值来**选择**下一条需要执行的命令

https://zhuanlan.zhihu.com/p/101495810



#### JVM、HotSpot，Openjdk关系

JVM是Java虚拟机规范，Hotspot是对JVM 规范的实现，而Openjdk是在HotSpot实现基础上开源的项目。

对JVM规范实现的还有JRockit，IBM J9



#### 简述JVM运行过程

javac编译器将源文件.java文件转换成.class字节码文件，通过class loader加载到运行时数据区中的方法区内，因为.class字节码文件是JVM的一套运行指令，底层系统是无法直接执行的，因此需要需要通过特定的执行引擎（execution engine）将字节码翻译成底层系统的执行命令，这个过程需要调用其他语言的本地接口（native interface）来实现

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/JVM.jpeg)



#### 什么对象不分配在堆内存

可以分配到栈上或者TLAB上

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/对象分配内存流程.png)


####  栈上分配是什么

栈上分配就是将对象分配到栈的内存中，栈上分配依赖**逃逸分析 (判断对象的作用域是否逃出方法体，-XX:+DoEscapeAnalysis 开启逃逸分析) **技术 和 **标量替换 （-XX:+EliminateAllocations 开启标量替换）**



#### TLAB是什么

全称 Thread Local Allocation Buffer 即线程本地分配缓存。TLAB本身占用eden区1%空间，在开启TLAB的情况下，虚拟机会为每个Java线程分配一块TLAB空间。分配顺序遵循先在栈上分配，如果失败则会进入TLAB分配



#### 逃逸分析是什么

逃逸分析的作用是判断对象的作用域是否逃出方法体，JIT会对代码进行优化的一种技术，目的是减少堆内存的压力。

逃逸分析分为方法逃逸和线程逃逸 。 

jdk1.7默认开启 逃逸分析 ，server模式下才能启用逃逸分析，为其它优化手段如栈上分配、标量替换和同步消除等提供依据。



#### 标量替换技术是什么

如果一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；



#### 同步消除技术是什么

线程同步本身是耗时耗能的过程，如果确定一个对象不会出现线程逃逸，那么对象就不会存在竞争，则可以同步消除对象的同步锁



#### 即时编译器？

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/JVM运行图.jpg)

当虚拟机发现**某个方法**或者**代码块**运行频繁，就会将此认为是热点代码（spot code）,为提高代码运行效率，虚拟机将此段代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这个任务的编译器叫做即时编译器（just in time compiler，JIT即时编译器）。

热点代码的次数配置参数 -XX:CompileThreshold。默认client是1500次，server是10000次



#### JIT（即时编译）是什么

通过在**运行时**将字节码编译为机器码，从而改善字节码编译语言性能的技术，只有热点代码才会执行JIT编译。HotSpot实现中有多种选择：C1、C2和C1+C2，分别对应client、server和分层编译。默认情况是异步进行的，当某方法或某代码块触发优化时，先将其放入**编译队列**，然后由编译线程进行编译
 1、C1编译速度快，优化方式比较保守；
 2、C2编译速度慢，优化方式比较激进；
 3、C1+C2在开始阶段采用C1编译，当代码运行到一定热度之后采用G2重新编译；
 在1.8之前，分层编译默认是关闭的，可以添加`-server -XX:+TieredCompilation`参数进行开启



#### HotSpot为什么内置了两个即时编译器？

分别是Client Complier和Server Complier，简称为C1、C2编译器。主流hotspot虚拟机默认采用解析器和其中一个编译器直接配合工作，使用哪个编译器由JVM运行模式决定，用户可以使用 “-client“ 或者 ”-server“参数强制制定运行哪种模式。区别在于

- client模式：获取更高的 编译速度，关注点是局部优化，放弃耗时过长的全局优化手段
- server模式：获取更高的 编译质量 ，是一个充分优化过的高级编译器，最求全局优化
- 分层编译：开始阶段采用client模式，当运行代码称为热点代码后采用server模式进行编译



#### AOT编译器

在**程序执行前**生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。



#### 解析器是什么

将Java字节码转成C++代码，再将C++代码编译成本地代码（硬编码），之所以会转成C++代码，是因为HotSpot虚拟机（本文中所说的Java虚拟机都是指HotSpot虚拟机）是C++代码编写的，所以Java字节码指令的底层实现都是由C++代码实现，执行字节码指令其实就是执行对应的C++代码，而执行C++代码之前会将C++代码编译成本地代码，然后再执行



#### 解析器和编译器的区别，优缺点

主流的HotSpot虚拟机采用的是解析器和编译器并存的框架，两则各有优略势

- 解析器：启动速度快运行速度慢
- 编译器：启动速度慢运行速度快，将字节码转成机器码后保存下来，方便下次再次使用，所以转换过程耗时，但是下次再用时可以快速执行



#### 哪些代码会被JIT编译器编译成本地代码，如何编译为本地代码

一些热点代码，比如 **被调用多次的方法**，**被多次执行的循环体**。编译器是以方法作为基本单元来编译的，编译是发生在方法执行的过程中，所以被称为 **栈上替换**



#### HotSpot虚拟机使用哪些热点检测方法？

计数器探测方式：为每个方法准备2个计数器，缺点是复杂，有点是精确

- **方法调用计数器**（统计方法被调用的次数）
- **回边计数器**（统计一个方法中**循环体**代码执行的次数），两个计数器都有一个阈值，超过阈值就会被认定为热点代码触发JIT编译

采样探测方式：虚拟机会周期性地检查各个**线程的栈顶**，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。优点是简单快速，缺点是不精确（线程阻塞的话）



#### 堆栈区别

1. 物理内存地址：堆的内存分配是不连续的，所以存在各种GC的算法，比如标记清除，标记压缩，复制算法等等，而栈的内存地址是连续
2. 内存分配时期：因为对的内存分配是不连续的，所以内存分配时期也就放到的运行时，而栈的分配时期是在编译期
3. 内存存放数据：堆存放对象的实例和数组，静态对象也存在堆中，静态变量则存放在方法区；栈存放局部变量，操作数栈，返回结果等等
4. 程序可见度：堆对于整个程序都是可见的，而栈仅对线程是可见的，也就是线程私有，生命周期和线程一致



#### 栈会发生内存溢出吗？

栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。



#### GC算法有哪些

1. 标记清除：标记无用对象，然后直接进行内存回收，缺点在于会产生内存碎片，内存空间不连续，分配内存会产生不必要的麻烦，有点是快

2. 标记压缩：标记无用对象，清除后会把存活的对象压缩到内存一边。缺点是耗时，优点是可以产生连续的空余内存

3. 复制算法：两块一样的内存，存活的移到一边，不存活的直接清除。优点是快，缺点是内从浪费

4. 分代算法：根据对象存活周期不同，划分了几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记压缩算法。Java8中，永久代被元数据区取代

   

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/JVM分代算法.png)

#### GC回收器有哪些

> 垃圾算法是内存回收的理论方法，那么垃圾回收器就是理论的实践，其中用于回收新生代的收集器包括serial，parNew，parallel scavenge；回收老年代的收集器包括：serial old，parallel old，CMS，还有用于回收整个Java堆的G1收集器。不同的收集器之间

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/JVM收集器.png)

serial（复制算法）：新生代算法，单线程收集器，标记和清理都是单线程，优点是效率高，垃圾回收的时候会STW（Stop The World），其他的工作线程都必须暂停

parNew（复制算法）：新生代并行使收集器，实际上是serial收集器的多线程版本，在多核CUP环境下，效率比serial高

parallel scavenge（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU、吞吐量=用户线程时间/(用户线程时间+GC时间)

serial old（标记整理算法）：老年代单线程收集器

parallel old（标记整理算法）：老年代并行收集器，吞吐量优先，parallel scavenge老年版

CMS（concurrent mark sweep，**标记清除算法**）：老年代并发收集器，追求最短的GC停顿时间，相对于其他的收集器STW的时间更短暂，-xx:+useConcMarkSweepGC配置，因为使用的是标记清除算法，所以会产生大量内存碎片，吞吐量不高，当内存不足运行时会报错Concurrent model failure,并临时采用serial old回收器。对象的标记使用 **三色标记** ：0,1,2 。 整个GC过程分为5步

1. 初始标记：标记GC ROOT直接引用的对象，需要较短STW（stop the world）,将GC对象压入标记栈
2. 并发标记：把对象从标记栈中弹出,递归找出所有引用对象,重复压入弹出,直到标记堆内的所有对象，存在多标（原本非垃圾对象，并发标记时被用户线程断开了引用链成为了垃圾对象，标记是标记非垃圾对象，垃圾对象不标，多标问题就会成为浮动垃圾，只有在下一次GC时才会被清除）、漏标问题（原本是垃圾对象，并发标记时被用户线程引用成了非垃圾对象），此时就要进行第三步，不需要STW
3. 重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生改变的对象，利用增量更新写屏障实现强三色不变式解决漏标问题，需要较长STW
4. 并发清除：清理删除掉标记阶段不可达的对象，不需要STW
5. 并发重置：重置GC过程中标记数据

G1（garbage first，标记整理算法）:Java堆并行收集器，JDK1.7提供的一个新收集器。重要特点是G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。G1收集器是JDK9的默认垃圾收集器，不再区分年轻代和老年代进行回收



#### JDK8默认的垃圾收集器（命令查看：java -XX:+PrintCommandLineFlags -version）

-XX:+UseParallelGC，新生代使用并发的parallel scavenge，老年代并发收集器使用parallel old，两个垃圾收集器都是追求高吞吐量，原则就是减少GC

Parallel Scavenge + Parallel Old



#### 增量更新和写屏障原理

增量更新和屏障是为了解决CMS在并发标记期间产生的漏标问题

- 增量更新：把并发标记期间状态变更为非垃圾的对象存在一个集合中，在重新标记期间修正对象的标记状态
- 写屏障：大概就是在标记状态前后各添加一个方法，实现一些逻辑



#### 简述分代垃圾回收器工作过程

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1 ，过程如下

- 把 Eden + From Survivor 存活的对象放入 To Survivor 区；
- 清空 Eden 和 From Survivor 分区；
- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。



#### 简述内存分配、回收以及Minor GC和Major GC

对象的内存分配，主要分配在eden中，如果是大对象则会直接分配到老年代（对象大小取决于配置的内存大小，如果堆内存是30 MB,则大对象的概念就是在1 MB左右，因为无法在新生代进行复制算法）。另外在新生代经历过15次Minor GC的对象也会进入到老年代

Minor GC：发生在新生代的GC，因为Java对象大多朝生夕死，所以minor GC会非常频繁，回收速度也很快

Major GC：发生在老年代的GC，出现Major GC一定伴随至少一次的Minor GC，一般Minor GC频率是Major GC的10倍



#### 类加载器是什么，有哪些类型

通过类文件的全限定名获取该类的二进制字节流叫做类加载器

主要的类加载器有四种：

1. 启动类加载器（bootstrap class Loader）：加载java核心类库，无法被java程序直接使用,默认会去加载JAVA_HOME/lib目录下的jar
2. 扩展类加载器（extensions class Loader）：加载Java扩展库。默认去加载JAVA_HOME/lib/ext目录下的jar
3. 应用程序类加载器（application class Loader）：比如web应用，会加载web程序中ClassPath下的类
4. 用户自定义加载器（user class Loader）：通过继承java.lang.ClassLoader类方式实现

![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/类加载器双亲委派模式.jpg)


#### 类加载过程（细节）

1. 加载：将class文件加载到JMM的方法区内
2. 验证：校验文件的正确性
3. 准备：为类中的静态变量分配内存
4. 解析：将文件中的符号引用转变成直接引用
5. 初始化：类中的静态变量和静态方法初始化
6. 使用



#### 双亲委派模式是什么？有什么作用

当一个类收到类加载请求时，不会自己去加载此类，而是将其委派给父类加载，如果父类不能加载，反馈回子类，在有子类完成类的加载。

好处：

1. 防止重复加载同一个.class 文件，保证加载一遍，确保数据安全
2. 核心.class文件不会被篡改，父类加载后，子类如果重新加载那只能说明两个类不是同一个类，确保了class执行的安全（**细节**）



#### JVM条有参数有哪些

1. -Xms4g ：初始化堆内存大小为4 g
2. -Xmx4g ：堆最大内存4 g
3. -XX:NewRation =4 ： 老年代/新生代，比例4 : 1
4. -XX:SurvivorRation=8 :新生到eden和survivor比例为8:  1
5. -XX:PrintGC ： 开启GC打印信息
6. -XX:printGCDetails ：打印GC详细信息



####  垃圾回收器并行和并发的区别

并行：用户线程会等待

并发：用户线程和垃圾回收线程交替运行



#### JVM主内存和工作内存

主内存：方法区，堆（线程数据共享）

工作内存：寄存器，虚拟机栈，本地方法栈（线程数据隔离）



#### JVM内存模型和多线程之间的关系

Java多线程并发问题最终都会反映到Java内存模型（JMM,java memory model）上，线程安全的问题是要控制多个线程对资源的有序访问和修改，简而言之Java内存模型就是要解决两个问题：可见性和有序性

- 可见性

  多线程之间是不能相互传递数据通信的，他们之间的沟通只能通过共享变量来进行，当new一个对象后，对象就会被分配到主内存中（堆中），每个线程都有自己的工作内存，存储了主内存的对象副本，当线程操作某个对象时，从主内存复制到工作内存（read and load），执行代码改变共享变量值（use and assign），工作内存刷新主内存相关内容（store and write）。共享变量在多线程的工作内存中都会存在副本，那么如果被一个线程修改后，其他线程就应该及时看到对应的变化，关键之volatile即可解决这个问题



#### 老年代可以使用复制算法吗？为什么

1. 老年代的空间比较大，采用复制算法的话，特别占用内存空间，分配8G，起到作用的只有4G
2. 复制算法比较频繁移动对象，对于在老年代对象多的会产生过多IO，效率下降



#### 如何判断对象已消亡

1. 引用计数法，给对象添加一个引用计数器，有地方用到+1，引用时效-1，当引用计数为0时，表示对象不再被使用，难以解决循环引用引起的问题
2. 可达性分析，GC ROOT作为根节点，开始向下搜索，搜索所有走过的路径称为**引用链**，当一个对象到GC ROOT 没有任何引用链相连接，则表示该对象不再被使用



#### 哪些对象可以作为GC ROOT

可达性分析算法定义的一个起始节点，GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。

方法区、虚拟机栈和本地方法栈不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。所以会被作为GC ROOT的对象有：

- 虚拟机栈（栈帧的局部变量表）所引用的对象；
- 本地方法栈的JNI所引用的对象；
- 方法区的静态变量、常量所引用的对象；



#### Full GC是什么？

当老年代空间不足时就会发生Full GC ，当发生Full GC时，会STW，除了GC线程其他线程都会被暂停，表现在应用层面上就是服务卡顿，响应缓慢。

发生Full GC的情况可能如下：

1. 调用System.gc()方法
2. 老年代，永久代内存不足
3. Minor GC对象进入老年代，而老年代空间不足。（经过15次minor gc的对象）
4. Eden区、FS（from survivor）区向TS（to survivor）区移动对象，但是对象大于TS空间，于是向老年代移动，不幸的是老年代也不够空间的时候



#### OOM原因

- 程序组存在死循环创建对象
- 静态变量和静态方法过多，因为静态变量和方法没办法被JVM回收
- 内存泄漏，比如静态集合，往里面放值，没办法被回收
- 大对象过多，将对象放入集合中
- 频繁的字符串拼接，不要用string。不要频繁创建大对象，尽量复用使用对象池



#### 频繁Full GC 如何排查（jstact，jmap命令细节）

1. 看配置是否正确，是否是eden区分配过小导致对象频繁进入老年期

2. 如果是内存泄漏的问题，通过以下步骤排查

   1. jstact -gcuit pid 或者查看gc.log日志，查看内存回收情况

      ![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/jvm-jstat排查.jpg)

      S0 S1 分别代表两个Survivor区占比；E代表Eden区占比；O代表老年代，M代表元空间，YGCT代表YGC累计耗时，GCT代表GC累计耗时

      ![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/gc-log.jpg)

   	2.	dump出内存文件具体分析，比如通过jmap命令jmap -dump:format=b,file=dumpfile pid，导出后通过eclipse Memory Analyzer工具分析
   	
    	3.	如果**CPU飙升**，同时Full GC。
          
            1. 使用命令top -c 找到CPU使用率高的进程
             2. 找到当前进程的pid，通过top -Hp pid  查看资源占用，找到线程
             3. 将线程pid转为16进制，printf "%x\n" pid
             4. jstack  pid | grep -A 10 tid(线程16进制)
             5. 如果问题还存在，就导出dump文件分析

#### Happens-before 

Java内存模型中，提供了happens-before原则来辅助synchronized，volatile保证程序执行的原子性，可见性，有序性。判断数据是否存在竞争，线程是否安全来保证。原则如下：

1. 程序顺序原则
2. 锁规则
3. volatile原则
4. 线程启动规则
5. 传递规则
6. 线程终止，中断规则
7. 对象终结规则

上述规则中无需手动添加同步也不会存在线程安全问题