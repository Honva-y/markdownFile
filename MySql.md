#### union和union all区别

union会对结果集中重复的数据进行去重，union all则将结果全部显示出来

union的效率要低于union all，因为有一个压缩的过程

扩展

intersect（相交）：对两个结果集做交集操作，不包括重复行

minus（减去）：对两个结果进行差集操作，不包括重复行



#### left join和inner join区别

left join：返回左表中所有数据和右表中符合条件的数据

inner join：返回符合条件的所有数据



#### 分组函数有哪些？

分组函数又叫聚合函数或者统计函数，包括sum(),count(),avg(),max(),min()

扩展

分组查询，使用group by，条件使用having。使用分组查询的字段在select中必须包含



#### ACID各代表什么

atomic 原子性，consistency 一致性，isolation隔离性，durability 持久性



#### for update是什么

MySQL悲观锁，对数据行进行加锁。事务提交改成手动

set autocommit = 0;



#### DDL ,DML是什么？

DML（data manipulation language，数据操纵语言），增删改查属于DML

DDL（data define language，数据定于语言），对表的修改都属于DDL

DCL（data control language,数据控制语言），修改数据库用户权限等操作



#### Mysql悲观锁是表锁还是行锁

取决于索引是否有命中，如果是命中索引那就是行锁，没有索引就是表锁。但是也会有一种情况，就是索引的区分度很低的时候，就会出现虽然命中了索引，但还是锁表的情况，比如将性别添加了索引



#### 聚集索引和非聚集索引

主键索引也被称为聚簇索引，非主键索引被称为非聚集索引

聚集索引：数据行的物理顺序与列值的逻辑顺序相同，一个表中只能拥有一个聚集索引，是一种单独的索引类型，而是一种数据存储方式。聚簇索引将**索引和数据行放到了一块**，找到索引也就找到了数据。因为无需进行回表操作，所以效率很高。缺点是 对表进行修改的速度较慢，因为为了保证表中记录的物理顺序和索引的顺序一致，会把记录插到数据页（叶子节点）的相应位置，所以会产生数据重排，而且插入新记录时为了维持B+树的特性，会频繁的分裂调整，影响了整体插入效率



#### 回表查询

InnoDB 中，对于主键索引，只需要走一遍主键索引的查询就能在叶子节点拿到数据。而对于普通索引，叶子节点存储的是key+主键值，因此需要再走一次主键索引找到行记录。先定位主键值，在定位行记录



#### ⾃增ID和UUID作为主键有什么不同？

innodb引擎中，如果写入顺序能和B+树索引的叶子节点顺序一致的话，存取效率是最高的。为了存储和查询性能应该使用自增长id做主键。

对应innodb索引，数据会按照主键进行排序，由于UUID的无序性，数据读写IO造成过大的压力，因此，UUID不适合做物理主键，可以把UUID作为逻辑主键，而自增ID仍然作为物理主键



#### B-tree和B+tree

二叉树：左节点小于根节点，右节点大于根节点，没有键值相同的点

AVL树（平衡二叉树）：所有节点左右子树高度差不超过1，查询快，新增删除慢

红黑树：根节点黑，叶子节点黑。相同路径长度下，黑节点一样多

B-Tree：平衡多路查找树，每个节点有多个分支，相比于AVL树，树高度小，磁盘IO就少，所有叶子节点位于同一层

B+Tree：非叶子节点只保存索引，数据都保存在叶子节点上，非叶子节点可以看成是索引的部分



#### 为什么**B+树比B树更适合数据库索引**？

1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3. 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
4. B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

https://blog.csdn.net/weixin_37645838/article/details/82778923



#### 事务隔离级别

| 隔离级别                     | 可能出现               |
| ---------------------------- | ---------------------- |
| read uncommitted（未提交读） | 脏读，幻读，不可重复读 |
| read committed （已提交读）  | 幻读，不可重复读       |
| repeated read （可重复读）   | 幻读                   |
| serializable （序列化）      | 无                     |



#### innodb引擎为什么不把行数记录起来？

事务具有隔离性，innodb通过MVCC（多版本并发控制）实现不同事务隔离级别时的不同效果，当有A,B,C三个事务查询数据的时候，可能得到不同的结果，所以只能通过count来实时计算得到总数。

#### MVCC是什么？

多版本并发控制（multiversion concurrency control），一种提高并发的技术。事务隔离级别的repeatable red是通过行级锁+MVCC共同实现，读不加锁，写的时候加锁。而MVCC实现依赖：隐藏字段，Read view，undo log。不做深入。https://blog.csdn.net/waves___/article/details/105295060





#### 脏读，不可重复读，幻读分别是什么？

- 脏读：A事务对数据进行了增删改，但未提交，B事务可以读取到未提交的数据。如果A事务这时候回滚了，那么B事务就读到了脏数据。

- 不可重复读（虚读）：在同一个事务之中，两个相同的查询得到的查询结果却不同，主要是在update/detele操作

  ![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/不可重复读.png)

- 幻读：A事务对一定范围的数据进行批量修改，B事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。

  ![](https://sz-note-md.oss-cn-beijing.aliyuncs.com/img/幻读.png)

#### mysam和innodb区别

| 对比点       | Innodb                                                | Myisam                                        |
| ------------ | ----------------------------------------------------- | --------------------------------------------- |
| 存储文件     | .frm 表定义文件  .idb数据存储文件  mysql8只有.idb文件 | .frm 表定义文件  .myi 索引文件  .myd 数据文件 |
| 支持的锁     | 表锁，行锁                                            | 表锁                                          |
| 事务         | ACID                                                  | 不支持事务                                    |
| 操作         | 读写                                                  | 读多写少                                      |
| count(1)操作 | 全表扫描                                              | 专门存储的地方                                |
| 索引结构     | B+树                                                  | B+树                                          |

myisam：不支持事务，只是表锁，存储表的总数，有三个文件索引文件，定义文件，数据文件，使用读多写少的业务场景

innodb：支持acid事务，支持表锁行锁，不存储表的总数，mysql8中只有.idb文件，8之前有定义表的文件和数据存储文件

#### innodb引擎四大特征 ？？？

1. 插入缓冲
2. 二次写入
3. 自适应hash索引
4. 预读

####  列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。



#### 时间戳转换成年月日

select from_unixtime（field,'%Y-%m-%d'）from table



#### BLOB和TEXT有什么区别？

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。



####  NOW（）和CURRENT_DATE（）有什么区别？

NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

CURRENT_DATE（）仅显示当前年份，月份和日期。



#### MYSQL支持事务吗？

在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。

AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式



#### Mysql里记录货币用什么字段类型好

NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总数 位数，而2(scale)代表将被用于存储小数点后的位数。能被存储在salary列中的值的范围是从-9999999.99到9999999.99。



#### 索引类型

主键索引：一张表只能有一个主键索引，且是唯一的

普通索引：加快查询速度，因为索引文件只包含了索引列字段，不包含整条数据，查询速度快，可以重复

唯一索引：和普通索引区别在于不能重复的数据，索引字段是唯一的

联合索引：当多个列需要被查询时，可以使用联合索引，可以同时命中，相比其他建立多个索引，消耗空间小

全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较



#### 索引失效情况

1. in查询，嵌套子查询
2. 被索引字段避免发生隐式转换。比如int类型字段使用字符串查询，比如代理商编号 2757680字符串  where agentId=2757680 会被认为是int类型
3. 前置模糊匹配，多索引最左匹配原则
4. 表达式计算，比如select * from t_user where f_age-2=18; 函数计算，比如select * from t_user where left(f_age,1)='10086';



#### explain分析sql语句好到差的等级排序

system-->const-->ref-->range-->index-->all(sacrria)

system:当查询的表只有一行的情况下，使用system

const:一次索引找到

ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

index：全索引扫描。index与ALL区别为index类型只遍历索引树

```text
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+
```

key(重要):列显示MySQL实际决定使用的键（索引）。**如果没有选择索引，键是NULL**。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。

```MYSQL
select * from table force index(user_name) where ....
```

更具体：https://zhuanlan.zhihu.com/p/111018455

#### Mysql优化

从三个方面入手：索引优化，sql优化，表优化

##### 索引优化建议

1. 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引
2.  尽量使用短索引，如果可以，应该制定一个前缀长度
3.  对于经常在where子句使用的列，最好设置索引，这样会加快查找速度
4.  对于有多个列where或者order by子句的，应该建立复合索引
5.  对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引
6.  尽量不要在列上进行运算（函数操作和表达式操作），避免隐式转换
7.  尽量不要使用not in和<>操作

##### SQL优化

- 找出慢sql
  - show_query_log,设置成on,捕获执行时间超过指定时间的sql语句
  - slow_query_log_file 记录日志的文件名
  - long_query_time设置成自己指定的时间，默认是10s
- 优化原则
  -  查询时，能不要 * 就不用 *，尽量写全字段名
  -  大部分情况连接效率远大于子查询
  -  多表连接时，尽量小表驱动大表，即小表 join 大表
  -  多使用explain和profile分析查询语句
  -  查看慢查询日志，找出执行时间长的sql语句优化
  -  在千万级分页时使用limit
  -  对于经常使用的查询，可以开启缓存

##### 表结构优化

- 字段尽可能使用Not NULL
- 创建自增字段，创建时间，更新时间
- 拆表，水平拆分和垂直拆分
  - 水平拆分：按在业务逻辑或者字段逻辑创建分表，分表表结构都一致
  - 垂直拆分：将表中相关性高的字段单独拆分成另一张表，形成一对一关系



